extern square: [rewrite_state, get_left, get_right, get_up, get_down, get_ether, get_creature, get_gamemaster, leave, enter, harvest, spawn]
extern body: [rewrite_state, move_left, move_right, move_up, move_down, get_location, get_ether, get_hp, get_brain, get_species, get_gamemaster, harvest, damage, attack_left, attack_right, attack_up, attack_down, _move]
extern creature_builder: [build_creature:iiii]
extern brain: [notify_of_turn]
extern gamemaster: [notify_of_spawn:i]

inset('basic_macros.se')

macro requires_turn():
    if msg.sender != self.brain:
        return(-1)

    if self.my_turn != 1:
        return(-1)

    self.my_turn = 0

data location
data ether
data hp
data brain
data species
data gamemaster
data creature_builder
data my_turn
data dead

def rewrite_state(location, ether, hp, brain, species, gamemaster, creature_builder):
    if self.gamemaster == 0 or self.gamemaster == msg.sender:
        self.location = location
        self.ether = ether
        self.hp = hp
        self.brain = brain
        self.species = species
        self.gamemaster = gamemaster
        self.creature_builder = creature_builder

def move_left():
    current_location = self.location
    neighbor = current_location.get_left(as=square)
    self._move(current_location, neighbor)

def move_right():
    neighbor = self.location.get_right(as=square)
    self.location = neighbor
    self._move(current_location, neighbor)

def move_up():
    neighbor = self.location.get_up(as=square)
    self.location = neighbor
    self._move(current_location, neighbor)

def move_down():
    neighbor = self.location.get_down(as=square)
    self.location = neighbor
    self._move(current_location, neighbor)

def get_location():
    return(self.location)

def get_ether():
    return(self.ether)

def get_hp():
    return(self.hp)

def get_brain():
    return(self.brain)

def get_species():
    return(self.species)

def get_gamemaster():
    return(self.gamemaster)

def harvest():
    requires_turn()

    location = self.location
    gain = location.harvest(as=square)
    self.ether = self.ether + gain
    return(gain)

def damage():
    self.hp = self.hp - 1

def attack_left():
    enemy_square = self.location.get_left(as=square)
    self._attack(enemy_square)

def attack_right():
    enemy_square = self.location.get_right(as=square)
    self._attack(enemy_square)

def attack_up():
    enemy_square = self.location.get_up(as=square)
    self._attack(enemy_square)

def attack_down():
    enemy_square = self.location.get_down(as=square)
    self._attack(enemy_square)

def reproduce_left(new_brain, endowment):
    location = self.location.get_left(as=square)
    return(self._reproduce(new_brain, location, endowment))

def reproduce_right(new_brain, endowment):
    location = self.location.get_right(as=square)
    return(self._reproduce(new_brain, location, endowment))

def reproduce_up(new_brain, endowment):
    location = self.location.get_up(as=square)
    return(self._reproduce(new_brain, location, endowment))

def reproduce_down(new_brain, endowment):
    location = self.location.get_down(as=square)
    return(self._reproduce(new_brain, location, endowment))

def notify_of_turn():
    authenticate(self.gamemaster)

    self.my_turn = 1
    self.brain.notify_of_turn(as=brain)
    self.my_turn = 0

def _reproduce(new_brain, location, endowment):
    requires_turn()
    private()

    ether = self.ether
    if endowment > ether:
        return(1)
    else:
        self.ether = ether - endowment
        species = self.species
        child = self.creature_builder.build_creature(new_brain, location, endowment, species, as=creature_builder)
        self.gamemaster.notify_of_spawn(child, as=gamemaster)
        return(child)

def _move(current_location, destination):
    requires_turn()
    private()

    if destination.get_creature(as=square) == 0:
        self.location = destination
        current_location.leave(as=square)
        destination.enter(as=square)
        return(1)

def _attack(enemy_square):
    requires_turn()
    private()

    enemy = enemy_square.get_creature(as=square)
    enemy.damage(as=body)
